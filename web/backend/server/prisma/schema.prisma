
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------- METADATA ----------

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  devices   Device[]
}

// Immutable physical interface (the actual hardware board)
model Nic {
  id        String   @id @default(cuid())
  mac       String   @unique
  deviceId  String?  @unique // A NIC can only be in one device at a time
  device    Device?  @relation(fields: [deviceId], references: [id], onDelete: SetNull)
  addedAt   DateTime @default(now())
}

enum DeviceStatus {
  ACTIVE
  INACTIVE
  DECOMMISSIONED
}

// Logical node in the device tree
model Device {
  id        String   @id @default(cuid())
  ownerId   String
  owner     User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  parentId  String?
  parent    Device?  @relation("DeviceTree", fields: [parentId], references: [id], onDelete: NoAction)
  children  Device[] @relation("DeviceTree")

  // The 'path' uses a native PostgreSQL type not directly supported by Prisma,
  // but Prisma will create it as a `text` column. You must alter it manually.
  // The trigger below will maintain this path automatically.
  path      String?  @db.Unsupported("ltree")
  alias     String?
  status    DeviceStatus @default(ACTIVE)

  // Foreign key to the current physical hardware (NIC)
  nicId     String?  @unique
  nic       Nic?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Telemetry Telemetry[]

  @@index([ownerId, status])
  @@index([path], type: Gist)
}

// ---------- TELEMETRY (TIME-SERIES DATA) ----------

model Telemetry {
  id        BigInt   @id @default(autoincrement())
  deviceId  String
  device    Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  
  eventTs   DateTime @db.Timestamp(6)
  leakRate  Float    @db.DoublePrecision
  pressure  Float    @db.DoublePrecision
  payload   Json?

  // Denormalized for faster queries on the hypertable
  ownerId   String

  @@index([deviceId, eventTs(sort: Desc)])
  @@index([ownerId, eventTs(sort: Desc)])
}



// -----------------------------------------------------------------------------
// IMPORTANT: MANUAL SQL REQUIRED AFTER `prisma migrate dev`
// -----------------------------------------------------------------------------
// Prisma does not manage TimescaleDB features or triggers.
// After Prisma creates the tables, run this SQL manually against your database.
// You can add this to a new migration file in your `prisma/migrations` folder.
/*

-- 1. Enable the ltree extension
CREATE EXTENSION IF NOT EXISTS ltree;

-- 2. Convert the Telemetry table into a TimescaleDB hypertable
SELECT create_hypertable('"Telemetry"', 'eventTs', chunk_time_interval => interval '7 days');

-- 3. Create the trigger function to automatically manage the `path` column for the device tree
CREATE OR REPLACE FUNCTION update_device_path() RETURNS trigger AS $$
  BEGIN
    IF NEW.parentId IS NULL THEN
      NEW.path = text2ltree(NEW.id);
    ELSE
      SELECT D.path || text2ltree(NEW.id)
      INTO NEW.path
      FROM "Device" AS D
      WHERE D.id = NEW.parentId;
    END IF;
    RETURN NEW;
  END;
$$ LANGUAGE plpgsql;

-- 4. Attach the trigger to the Device table
CREATE TRIGGER trg_device_path_update
BEFORE INSERT OR UPDATE OF parentId ON "Device"
FOR EACH ROW EXECUTE PROCEDURE update_device_path();

-- 5. (OPTIONAL BUT RECOMMENDED) Create continuous aggregate for fast dashboard queries
CREATE MATERIALIZED VIEW telemetry_hourly
WITH (timescaledb.continuous) AS
SELECT
  "ownerId",
  "deviceId",
  time_bucket('1 hour', "eventTs") AS hour,
  AVG("leakRate") AS leak_avg,
  MAX("leakRate") AS leak_peak,
  MIN("leakRate") AS leak_min
FROM "Telemetry"
GROUP BY "ownerId", "deviceId", hour;

*/